<!DOCTYPE html>
<html><body>
<script src="https://aframe.io/releases/0.3.0/aframe.min.js"></script>
<script src="https://cdn.rawgit.com/AltspaceVR/AltspaceSDK/v2.0.2/dist/altspace.min.js"></script>
<script src="https://cdn.rawgit.com/mrdoob/three.js/r84/build/three.min.js"></script>
<script src="../../dist/altspace.js"></script>

<!-- set up the scene -->
<a-scene altspace='vertical-align: bottom;'>
 
    <!-- add a view camera (2d only) -->
    <a-text value="Hello, World!"></a-text>

    <a-assets>
    <img id="m1" src="assets/m1.png">
    <img id="m2" src="assets/m2.png">
    <img id="m3" src="assets/m3.png">
    <img id="m4" src="assets/m4.png">
    <img id="m5" src="assets/m5.png">
    <img id="m6" src="assets/m6.png">
    <img id="m7" src="assets/m7.png">
    <img id="m8" src="assets/m8.png">
    <img id="mblank" src="assets/m_blank.png">
    <img id="mmine" src="assets/m_mine.png">
    <img id="resetB" src="assets/resetButton">
    <img id="flagMode" src="assets/flagMode">
    <img id="normMode" src="assets/normalMode">

  </a-assets>

    <!--<a-entity geometry="primitive: box" material="shader: flat; src: #my-texture" position = '0 1 0'></a-entity>-->


    <a-entity position='0 0 2'>
        <a-camera></a-camera>
    </a-entity>
 
</a-scene>
 
</body>

<script>



//--- synchronisation

var utilities = altspace.utilities;
var behaviors = altspace.utilities.behaviors;

var sim = new utilities.Simulation();
var inCodePen = utilities.codePen.inCodePen;
var instanceRef;

	utilities.sync.connect({
		appId: 'AddingCubes',
		authorId: inCodePen ? utilities.codePen.getAuthorId() : 'AltspaceVR',
		instanceId: inCodePen ? utilities.codePen.getPenId() : null
	}).then(function(connection) {
	instanceRef = connection.instance;

//---

var scene;
//var sim = new altspace.utilities.Simulation();

var Y_WIDTH;
var Z_WIDTH; 
var MINE_NO;
var GAME_OVER;
var rand;
var mines;
var tiles;
var objects;
var objects2;
var flagging;
var revealed;
var obj_other;

reset();

//uses for testing
function box2render(){
	var box2 = document.createElement('a-box');

	box2.setAttribute('width', '1');	
	box2.setAttribute('height', '1');
	box2.setAttribute('depth','1');
	box2.setAttribute('color','#00FF00');
	box2.setAttribute('position', '0 1 0');

	scene.appendChild(box2);  //the box of testing
	obj_other.push(box2);
}

function edgeRender(){

	var edge1 = document.createElement('a-box');

	edge1.setAttribute('width', '0.1');	
	edge1.setAttribute('height', '0.3');
	edge1.setAttribute('depth', 0.2*Y_WIDTH);
	edge1.setAttribute('color','#000000');
	edge1.setAttribute('position', '-2.15 0 -0.5');

	var edge2 = document.createElement('a-box');

	edge2.setAttribute('width', '0.1');	
	edge2.setAttribute('height', '0.3');
	edge2.setAttribute('depth', 0.2*Y_WIDTH);
	edge2.setAttribute('color','#000000');
	edge2.setAttribute('position', '1.15 0 -0.5');

	var edge3 = document.createElement('a-box');

	edge3.setAttribute('width', 0.2*Z_WIDTH);	
	edge3.setAttribute('height', '0.3');
	edge3.setAttribute('depth', '0.1');
	edge3.setAttribute('color','#000000');
	edge3.setAttribute('position', '-0.5 0 -2.15');

	var edge4 = document.createElement('a-box');

	edge4.setAttribute('width', 0.2*Z_WIDTH);	
	edge4.setAttribute('height', '0.3');
	edge4.setAttribute('depth', '0.1');
	edge4.setAttribute('color','#000000');
	edge4.setAttribute('position', '-0.5 0 1.15');


	scene.appendChild(edge1);
	scene.appendChild(edge2);
	scene.appendChild(edge3);
	scene.appendChild(edge4);
}

//renders screen
function cubeRender(y,z){

	var flagged = false;
	var box3 = new THREE.Mesh(

		new THREE.BoxGeometry(0.2,0.2,0.2),
		new THREE.MeshBasicMaterial({color:0x4c4c4c})

		);

	box3.position.set((y-10)*0.2, 0.01, (z-10)*0.2);

	box3.addEventListener('cursordown', function(){
		
		if (flagging == true){
			if (flagged == false){
				box3.material.color.setHex(0xffcc00);
				flagged = true;
			} else {
				box3.material.color.setHex(0x4c4c4c);
				flagged = false;
			}
		}else{
		//sim.scene.remove(box3);
		//revealed[y*Y_WIDTH + z] = true;
		checkTile(y,z);
		}
	});


	objects.push(box3);
	sim.scene.add(box3);

}//end box3render

function mineCheck(y,z){
		// minecheck2
		// loop through all 8 tiles around
		//checks if current tile is NOT a mine
		if (tiles[y*Y_WIDTH + z] != 90) {

			var	counter = 0;

			if (tiles[(y+1)*Y_WIDTH + z] == 90){counter++}
			if (tiles[(y-1)*Y_WIDTH + z] == 90){counter++}

			if((y*Y_WIDTH +z) %Y_WIDTH != 0){
				if (tiles[(y+1)*Y_WIDTH + (z-1)] == 90){counter++}
				if (tiles[(y)*Y_WIDTH + (z-1)] == 90){counter++}
				if (tiles[(y-1)*Y_WIDTH + (z-1)] == 90){counter++}
			}
			if ((y*Y_WIDTH + z) %Y_WIDTH != Y_WIDTH-1 ){
				if (tiles[(y-1)*Y_WIDTH + (z+1)] == 90){counter++}
				if (tiles[(y+1)*Y_WIDTH + (z+1)] == 90){counter++}
				if (tiles[(y)*Y_WIDTH + (z+1)] == 90){counter++}
			}
			tiles[y*Y_WIDTH + z] = counter;

		}//end mine check
}//endminecheck function

//checks tile clicked on
function checkTile(y,z){

	revealed[y*Y_WIDTH + z] = true;

	if(tiles[y*Y_WIDTH + z] == 90){

		GAME_OVER = true;
		for (var i=0; i<objects.length; i++){
			sim.scene.remove(objects[i]);
		}
		//box2render();

	}//end tiles=90

	if(tiles[y*Y_WIDTH + z] == 0){
		
		//makes sure all variations of the thing can be thinged
		for (var loop=0; loop<Y_WIDTH; loop++){
		revealTiles();
	}
		//box2render();
	}//tiles = 0 end

	//box2render();
	removeTiles();
}

function removeTiles(){

	for (var ii = 0; ii<Y_WIDTH; ii++){
		for (var jj = 0; jj<Y_WIDTH; jj++){

			if (revealed[ii*Y_WIDTH + jj] == true){
				sim.scene.remove(objects[ii*Y_WIDTH + jj]);
			}

		}
	}

	//check for win
	//checks howmany unclicked tiles there are and compares with no of mines
	var count = 0;
	for (var c = 0; c<revealed.length; c++){
		if (revealed[c] == false){
			count ++;
		}
	}

	if (count==MINE_NO){
		//WIN
		box2render();
	}

}

function revealTiles(){

	for(var i = 0; i<Y_WIDTH; i++){
		for(var j = 0; j<Z_WIDTH; j++){

			if(revealed[i*Y_WIDTH + j] == true && tiles[i*Y_WIDTH +j] == 0){

				revealed[(i-1)*Y_WIDTH + j] = true;
				revealed[(i+1)*Y_WIDTH + j] = true;
				
				if((i*Y_WIDTH +j) %Y_WIDTH != 0){
					revealed[i*Y_WIDTH + j-1] = true;
					revealed[(i+1)*Y_WIDTH + j-1] = true;
					revealed[(i-1)*Y_WIDTH + j-1] = true;
				}
				if ((i*Y_WIDTH + j) %Y_WIDTH != Y_WIDTH-1 ){
					revealed[(i-1)*Y_WIDTH + j+1] = true;
					revealed[i*Y_WIDTH + j+1] = true;
					revealed[(i+1)*Y_WIDTH + j+1] = true;
				}
			}

	}//end i loop
}

}//end reveal tiles

function setColors(box, y, z){

	switch(tiles[y*Y_WIDTH + z]){
			case 0:
			box.setAttribute('color', '#ECACEC');
			box.setAttribute('material', 'shader: flat; src: #mblank');
			break;
			case 1:
			box.setAttribute('color', '#00ffcc'); //cyan
			box.setAttribute('material', 'shader: flat; src: #m1');
			break;
			case 2:
			box.setAttribute('color', '#6600ff'); //purple
			box.setAttribute('material', 'shader: flat; src: #m2');
			break;
			case 3:
			box.setAttribute('color', '#00ff00'); //lime green
			box.setAttribute('material', 'shader: flat; src: #m3');
			break;
			case 4:
			box.setAttribute('color', '#009900'); //dark green
			box.setAttribute('material', 'shader: flat; src: #m4');
			break;
			case 5:
			box.setAttribute('color', '#fff000'); //yellow
			box.setAttribute('material', 'shader: flat; src: #m5');
			break;
			case 6:
			box.setAttribute('color', '#000dff'); //dark blue
			box.setAttribute('material', 'shader: flat; src: #m6');
			break;
			case 7:
			box.setAttribute('color', '#8c00ff'); //purple
			box.setAttribute('material', 'shader: flat; src: #m7');
			break;
			case 8:
			box.setAttribute('color', '#000000'); //black
			box.setAttribute('material', 'shader: flat; src: #m8');
			break;

			case 90:
			box.setAttribute('color', '#ff0000'); //red
			box.setAttribute('material', 'shader: flat; src: #mmine');
			break;


		}
}//end setColors

//sets mines
function setMines(){

	//set mine positions
	for(var i=0; i<MINE_NO; i++){

		rand = Math.floor(Math.random()*(Y_WIDTH*Z_WIDTH));
		mines.push(rand);

	}

	for(var y = 0; y<Y_WIDTH; y++){
	for(var z=0; z<Z_WIDTH; z++){
		//loop through mines array
		for(var mn=0; mn < mines.length; mn++){
			//temporary variable to hold mine that is being checked
			var t1 = mines[mn];
			//set mines
			if(y*Y_WIDTH + z == t1){	tiles[t1] = 90 }
		}//end for mn
	}//end for z
	}//end for y	
}

//drawsgrid
function drawGrid(){
	for(var y = 0; y<Y_WIDTH; y++){
	for(var z=0; z<Z_WIDTH; z++){

	revealed[y*Y_WIDTH + z] = false;

	cubeRender(y,z);
	//create box
	var box = document.createElement('a-entity');
	box.setAttribute('geometry', 'primitive: box; width: 0.2; height: 0.2; depth: 0.2;');
	//box.setAttribute('material', 'shader: flat; src: #mblank')

	mineCheck(y,z);
	setColors(box, y, z);

	//set box position
	box.setAttribute('position', (y-10)*0.2 + ' 0 ' + (z-10)*0.2);
		
	//add box to scene
	scene.appendChild(box);
	objects2.push(box);
	}//end for z
	}//end for x
}

//resets app
function reset(){

	initialiseVars();
	edgeRender();
	setMines();
	drawGrid();
	drawControls();
}

function wipeObjects(){
	for (var i=0; i<objects2.length; i++){
		scene.remove(objects2[i]);
	}
	for (var i=0; i<objects.length; i++){
		sim.scene.remove(objects[i]);
	}
	for (var i=0; i<obj_other.length; i++){
		scene.remove(obj_other[i]);
	}
}



function initialiseVars(){

	scene = document.querySelector('a-scene');

	Y_WIDTH = 16;
	Z_WIDTH = 16; 
	MINE_NO = 40; //40
	GAME_OVER = false;
	mines = [];
	tiles = [];
	objects = [];
	objects2 = [];
	flagging = false;
	revealed = [];
	obj_other = [];
}

function drawControls(){
	var flagGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5); 

	var flagTex = new THREE.ImageUtils.loadTexture("assets/flagMode.png");
	var flagTex2 = new THREE.ImageUtils.loadTexture("assets/normalMode.png"); 
	var resTex = new THREE.ImageUtils.loadTexture("assets/resetButton.png");
	

	var flagMat = new THREE.MeshBasicMaterial({ 
                    map:flagTex, 
                    side:THREE.DoubleSide 
                 }); 
	var flagMat2 = new THREE.MeshBasicMaterial({ 
                    map:flagTex2, 
                    side:THREE.DoubleSide 
                 }); 
	var resMat = new THREE.MeshBasicMaterial({ 
                    map:resTex, 
                    side:THREE.DoubleSide 
                 }); 

	var flag_box = new THREE.Mesh(flagGeo, flagMat);
	var flag_box2 = new THREE.Mesh(flagGeo, flagMat2);
	var reset_box = new THREE.Mesh(flagGeo, resMat);

	flag_box.position.set(1, 0.25, 2);
	flag_box2.position.set(1, 0.75, 2);
	reset_box.position.set(1.5, 0.25, 2);

	flag_box.addEventListener('cursordown', function(){
		
		if (flagging == false){
			flagging = true;
		}

	});

	flag_box2.addEventListener('cursordown', function(){
		
		if (flagging == true){
			flagging = false;
		}

	});

	reset_box.addEventListener('cursordown', function(){
		
		wipeObjects();
		reset();
		//box2render();

	});



	sim.scene.add(flag_box);
	sim.scene.add(flag_box2);
	sim.scene.add(reset_box);
}

function ready(firstInInstance) {
				if (firstInInstance) {
					reset();
			}
}
});



</script>
</html>