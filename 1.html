<!DOCTYPE html>
<html><body>
<script src="https://aframe.io/releases/0.3.0/aframe.min.js"></script>
<script src="https://cdn.rawgit.com/AltspaceVR/AltspaceSDK/v2.0.2/dist/altspace.min.js"></script>
<script src="https://cdn.rawgit.com/mrdoob/three.js/r84/build/three.min.js"></script>
<script src="../../dist/altspace.js"></script>
<script src="https://rawgit.com/bryik/aframe-bmfont-text-component/master/dist/aframe-bmfont-text-component.min.js"></script>

<!-- set up the scene -->
<a-scene altspace='vertical-align: bottom;'>
 
    <!-- add a view camera (2d only) -->
    <!--<a-text value="Hello, World!"></a-text>-->

    <a-assets>
    <img id="win" src="assets/win.png">
    <img id="lose" src="assets/lose.png">
  	</a-assets>

    <!--<a-entity geometry="primitive: box" material="shader: flat; src: #m1" position = '0 1 0'></a-entity>-->
    <a-entity bmfont-text="text: HELLO!; color: #333" position="0 1 0"></a-entity>

    <a-entity position='0 0 2'>
        <a-camera></a-camera>
    </a-entity>
 
</a-scene>
 
</body>

<script>

//altspace.getEnclosure().then(function(enclosure){
       // enclosure.requestFullspace();
   //});

//--- synchronisation

var utilities = altspace.utilities;
var behaviors = altspace.utilities.behaviors;

var sim = new utilities.Simulation();
var inCodePen = utilities.codePen.inCodePen;
var instanceRef;

	utilities.sync.connect({
		appId: 'Minesweeper',
		authorId: inCodePen ? utilities.codePen.getAuthorId() : 'AltspaceVR',
		instanceId: inCodePen ? utilities.codePen.getPenId() : null
	}).then(function(connection) {
	instanceRef = connection.instance;


//---

var scene;
//var sim = new altspace.utilities.Simulation();

var Y_WIDTH;
var Z_WIDTH; 
var MINE_NO;
var GAME_OVER;
var rand;
var mines;
var tiles;
var flags;
var objects;
var objects2;
var flagging;
var revealed;
var obj_other;

var boxGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);;

var mineTexTest;
var mineMatTest;

//var flagTex = new THREE.ImageUtils.loadTexture("assets/flagMode.png");

reset();
//box2render();

//uses for testing
function box2render(){
	var box2 = document.createElement('a-entity');

	box2.setAttribute('geometry', 'primitive: box; width: 2; height: 1; depth: 0.01;');
	box2.setAttribute('color','#00FF00');
	box2.setAttribute('position', '-0.5 1 -2.5');

	if (GAME_OVER == false){
		box2.setAttribute('material', 'shader: flat; src: #win');
	} else {
		box2.setAttribute('material', 'shader: flat; src: #lose');
	}

	scene.appendChild(box2);  //the box of testing
	obj_other.push(box2);
}

function edgeRender(){

	var edge1 = document.createElement('a-box');

	edge1.setAttribute('width', '0.1');	
	edge1.setAttribute('height', '0.3');
	edge1.setAttribute('depth', 0.2*Y_WIDTH);
	edge1.setAttribute('color','#000000');
	edge1.setAttribute('position', '-0.15 0.1 ' + ((Y_WIDTH-1) *0.2) /2);

	var edge2 = document.createElement('a-box');

	edge2.setAttribute('width', '0.1');	
	edge2.setAttribute('height', '0.3');
	edge2.setAttribute('depth', 0.2*Y_WIDTH);
	edge2.setAttribute('color','#000000');
	edge2.setAttribute('position', (0.15+((Y_WIDTH-1) *0.2)) +' 0.1 ' + ((Y_WIDTH-1) *0.2) /2);

	var edge3 = document.createElement('a-box');

	edge3.setAttribute('width', 0.2*Z_WIDTH);	
	edge3.setAttribute('height', '0.3');
	edge3.setAttribute('depth', '0.1');
	edge3.setAttribute('color','#000000');
	edge3.setAttribute('position', ((Z_WIDTH-1) *0.2) /2 + ' 0.1 -0.15');

	var edge4 = document.createElement('a-box');

	edge4.setAttribute('width', 0.2*Z_WIDTH);	
	edge4.setAttribute('height', '0.3');
	edge4.setAttribute('depth', '0.1');
	edge4.setAttribute('color','#000000');
	edge4.setAttribute('position', ((Z_WIDTH-1) *0.2) /2 + ' 0.1 ' + (0.15+((Z_WIDTH-1) *0.2)));


	scene.appendChild(edge1);
	scene.appendChild(edge2);
	scene.appendChild(edge3);
	scene.appendChild(edge4);
}

//renders screen
function cubeRender(y,z){

	var cTex = new THREE.ImageUtils.loadTexture("assets/unclickedtile.png");
	var cMat = new THREE.MeshBasicMaterial({ 
                    map:cTex, 
                    side:THREE.DoubleSide 
                 }); 

	var flagged = false;
	var box3 = new THREE.Mesh(boxGeo, cMat);

	box3.position.set((y)*0.2, 0.11, (z)*0.2);

	box3.addEventListener('cursordown', function(){
		
		if (flagging == true){
			if (flagged == false){
				//box3.material.color.setHex(0xffcc00);
				//render a flag instead
				
				flagTile(flagged, y, z);
				flagged = true;
			} else {
				//box3.material.color.setHex(0x4c4c4c);
				//flagged = false;
				flagTile(flagged, y, z);
				flagged = false;
			}
		}else{
		checkTile(y,z);
		}
	});


	objects.push(box3);
	sim.scene.add(box3);

}//end box3render

function flagTile(flagged, y, z){

	var fTex = new THREE.ImageUtils.loadTexture("assets/flag.png");
	var fMat = new THREE.MeshBasicMaterial({ 
                    map:fTex, 
                    side:THREE.DoubleSide 
                 }); 

		var flagGeo = new THREE.BoxGeometry	(0.02, 0.2, 0.02);
		var flag1 = new THREE.Mesh(flagGeo, fMat);

		if (flagged == false){
		flag1.position.set(y*0.2, 0.2, z*0.2);

		sim.scene.add(flag1);
		flags[y*Y_WIDTH + z] = flag1;
		//flagg  = true;
		} else {
			sim.scene.remove(flags[y*Y_WIDTH + z]);
			//flagged = false;
		}


}

function mineCheck(y,z){
		// minecheck2
		// loop through all 8 tiles around
		//checks if current tile is NOT a mine
		if (tiles[y*Y_WIDTH + z] != 90) {

			var	counter = 0;

			if (tiles[(y+1)*Y_WIDTH + z] == 90){counter++}
			if (tiles[(y-1)*Y_WIDTH + z] == 90){counter++}

			if((y*Y_WIDTH +z) %Y_WIDTH != 0){
				if (tiles[(y+1)*Y_WIDTH + (z-1)] == 90){counter++}
				if (tiles[(y)*Y_WIDTH + (z-1)] == 90){counter++}
				if (tiles[(y-1)*Y_WIDTH + (z-1)] == 90){counter++}
			}
			if ((y*Y_WIDTH + z) %Y_WIDTH != Y_WIDTH-1 ){
				if (tiles[(y-1)*Y_WIDTH + (z+1)] == 90){counter++}
				if (tiles[(y+1)*Y_WIDTH + (z+1)] == 90){counter++}
				if (tiles[(y)*Y_WIDTH + (z+1)] == 90){counter++}
			}
			tiles[y*Y_WIDTH + z] = counter;

		}//end mine check
}//endminecheck function

//checks tile clicked on
function checkTile(y,z){

	revealed[y*Y_WIDTH + z] = true;

	if(tiles[y*Y_WIDTH + z] == 90){

		GAME_OVER = true;
		for (var i=0; i<objects.length; i++){
			sim.scene.remove(objects[i]);
			
		}
		lose();
	}//end tiles=90

	if(tiles[y*Y_WIDTH + z] == 0){
		
		//makes sure all variations of the thing can be thinged
		for (var loop=0; loop<Y_WIDTH; loop++){
		revealTiles();
	}
	}//tiles = 0 end

	removeTiles();
}

function removeTiles(){

	for (var ii = 0; ii<Y_WIDTH; ii++){
		for (var jj = 0; jj<Y_WIDTH; jj++){

			if (revealed[ii*Y_WIDTH + jj] == true){
				sim.scene.remove(objects[ii*Y_WIDTH + jj]);
			}

		}
	}

	//check for win
	//checks howmany unclicked tiles there are and compares with no of mines
	var count = 0;
	for (var c = 0; c<revealed.length; c++){
		if (revealed[c] == false){
			count ++;
		}
	}

	if (count==MINE_NO){
		//WIN
		win();
	}

}

function win(){
	box2render();
	//do stuff with highscores or something here
}

function lose(){

		box2render();
}

function revealTiles(){

	for(var i = 0; i<Y_WIDTH; i++){
		for(var j = 0; j<Z_WIDTH; j++){

			if(revealed[i*Y_WIDTH + j] == true && tiles[i*Y_WIDTH +j] == 0){

				revealed[(i-1)*Y_WIDTH + j] = true;
				revealed[(i+1)*Y_WIDTH + j] = true;
				
				if((i*Y_WIDTH +j) %Y_WIDTH != 0){
					revealed[i*Y_WIDTH + j-1] = true;
					revealed[(i+1)*Y_WIDTH + j-1] = true;
					revealed[(i-1)*Y_WIDTH + j-1] = true;
				}
				if ((i*Y_WIDTH + j) %Y_WIDTH != Y_WIDTH-1 ){
					revealed[(i-1)*Y_WIDTH + j+1] = true;
					revealed[i*Y_WIDTH + j+1] = true;
					revealed[(i+1)*Y_WIDTH + j+1] = true;
				}
			}

	}//end i loop
	}
}//end reveal tiles

function setColors(box, y, z){

	switch(tiles[y*Y_WIDTH + z]){
			case 0:
			mineMatTest = new THREE.ImageUtils.loadTexture("assets/m_blank.png");
			break;
			case 1:
			mineMatTest = new THREE.ImageUtils.loadTexture("assets/m1.png");
			break;
			case 2:
			mineMatTest = new THREE.ImageUtils.loadTexture("assets/m2.png");
			break;
			case 3:
			mineMatTest = new THREE.ImageUtils.loadTexture("assets/m3.png");
			break;
			case 4:
			mineMatTest = new THREE.ImageUtils.loadTexture("assets/m4.png");
			break;
			case 5:
			mineMatTest = new THREE.ImageUtils.loadTexture("assets/m5.png");
			break;
			case 6:
			mineMatTest = new THREE.ImageUtils.loadTexture("assets/m6.png");
			break;
			case 7:
			mineMatTest = new THREE.ImageUtils.loadTexture("assets/m7.png");
			break;
			case 8:
			mineMatTest = new THREE.ImageUtils.loadTexture("assets/m8.png");
			break;

			case 90:
			mineMatTest = new THREE.ImageUtils.loadTexture("assets/m_mine.png");
			break;

		}

		//woopsies
		mineTexTest = new THREE.MeshBasicMaterial({ map: mineMatTest, side:THREE.DoubleSide }); 
}//end setColors

//sets mines
function setMines(){
	rand = Math.floor(Math.random()*(Y_WIDTH*Z_WIDTH));
	mines.push(rand);
	//set mine positions
	

	for(var i=0; i<MINE_NO-1; i++){
		
		var dupe = false;
		// /rand = Math.floor(Math.random()*(Y_WIDTH*Z_WIDTH));
		//make sure mine doesnt already exist
		do{
			dupe = false;
			rand = Math.floor(Math.random()*(Y_WIDTH*Z_WIDTH));
			
			for(var k = 0; k<mines.length; k++){
				if (mines[k] == rand){dupe = true;}
			}


		}while(dupe == true);

		mines.push(rand);
	}

	for(var y = 0; y<Y_WIDTH; y++){
	for(var z=0; z<Z_WIDTH; z++){
		//loop through mines array
		for(var mn=0; mn < mines.length; mn++){
			//temporary variable to hold mine that is being checked
			var t1 = mines[mn];
			//set mines
			if(y*Y_WIDTH + z == t1){	tiles[t1] = 90 }
		}//end for mn
	}//end for z
	}//end for y	
}

//drawsgrid
function drawGrid(){
	for(var y = 0; y<Y_WIDTH; y++){
	for(var z=0; z<Z_WIDTH; z++){

	revealed[y*Y_WIDTH + z] = false;

	cubeRender(y,z);
	//create box
	var box;

	mineCheck(y,z);
	setColors(box, y, z);
	box = new THREE.Mesh(boxGeo, mineTexTest);

	//set box position
	//box.setAttribute('position', (y-10)*0.2 + ' 0.1 ' + (z-10)*0.2);
	box.position.set((y)*0.2 , 0.1, (z)*0.2);

	//add box to scene
	//scene.appendChild(box);
	sim.scene.add(box);
	objects2.push(box);
	}//end for z
	}//end for x
}

//resets app
function reset(){
	//wipeObjects();
	initialiseVars();
	edgeRender();
	setMines();
	drawGrid();
	drawControls();
}

function wipeObjects(){
	for (var i=0; i<objects2.length; i++){
		sim.scene.remove(objects2[i]);
	}
	for (var i=0; i<objects.length; i++){
		sim.scene.remove(objects[i]);
	}
	for (var i=0; i<obj_other.length; i++){
		scene.remove(obj_other[i]);
	}
	for (var i=0; i<flags.length; i++){
		sim.scene.remove(flags[i]);
	}
}



function initialiseVars(){

	scene = document.querySelector('a-scene');

	Y_WIDTH = 30;
	Z_WIDTH = 30; 
	MINE_NO = 175; //40
	GAME_OVER = false;
	mines = [];
	tiles = [];
	flags = [];
	objects = [];
	objects2 = [];
	flagging = false;
	revealed = [];
	obj_other = [];
}

function drawControls(){
	var flagGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5); 

	var flagTex = new THREE.ImageUtils.loadTexture("assets/flagMode.png");
	var flagTex2 = new THREE.ImageUtils.loadTexture("assets/normalMode.png"); 
	var resTex = new THREE.ImageUtils.loadTexture("assets/resetButton.png");
	

	var flagMat = new THREE.MeshBasicMaterial({ 
                    map:flagTex, 
                    side:THREE.DoubleSide 
                 }); 
	var flagMat2 = new THREE.MeshBasicMaterial({ 
                    map:flagTex2, 
                    side:THREE.DoubleSide 
                 }); 
	var resMat = new THREE.MeshBasicMaterial({ 
                    map:resTex, 
                    side:THREE.DoubleSide 
                 }); 

	var flag_box = new THREE.Mesh(flagGeo, flagMat);
	var flag_box2 = new THREE.Mesh(flagGeo, flagMat2);
	var reset_box = new THREE.Mesh(flagGeo, resMat);

	flag_box.position.set(-2, 0.25, -3);
	flag_box2.position.set(-2, 0.75, -3);
	reset_box.position.set(-2.5, 0.25, -3);

	flag_box.addEventListener('cursordown', function(){
		
		if (flagging == false){
			flagging = true;
		}

	});

	flag_box2.addEventListener('cursordown', function(){
		
		if (flagging == true){
			flagging = false;
		}

	});

	reset_box.addEventListener('cursordown', function(){
		
		wipeObjects();
		reset();
		//box2render();

	});



	sim.scene.add(flag_box);
	sim.scene.add(flag_box2);
	sim.scene.add(reset_box);
}

function ready(firstInInstance) {
		if (firstInInstance) {
			reset();
		}
}


});



</script>
</html>
